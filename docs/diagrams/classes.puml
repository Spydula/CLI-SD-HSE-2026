@startuml classes
title Интерпретатор командной строки — ключевые классы (подстановка до токенизации)
skinparam shadowing false
skinparam classAttributeIconSize 0

class Shell {
  - Environment env
  - Expander expander
  - Lexer lexer
  - Parser parser
  - Executor executor
  + int run()
  + void runLine(string line)
}

' ====== Pre-expansion ======
class Expander {
  + string expandLine(string rawLine, Environment env)
  - string expandVar(string name, Environment env)
}

note right of Expander
expandLine выполняет подстановки $NAME с учётом кавычек:
- в '...' подстановок нет
- в "..." подстановки есть
- вне кавычек подстановки есть

Если значение содержит пробелы, Expander
оборачивает вставку служебными маркерами,
чтобы Lexer не разделил её на несколько аргументов.
end note

' ====== Lexing/Parsing ======
class Lexer {
  + vector<Token> tokenize(string line)
}

enum TokenType {
  WORD
  PIPE
  EOL
}

class Token {
  + TokenType type
  + string text
}

class Parser {
  + PipelineNode parse(vector<Token> tokens)
}

class PipelineNode {
  + vector<CommandNode> commands
}

class CommandNode {
  + vector<AssignmentNode> assignments
  + vector<string> words
}

class AssignmentNode {
  + string name
  + string value
}

' ====== Environment ======
class Environment {
  - map<string,string> vars
  + void set(string name, string value)
  + optional<string> get(string name) const
  + map<string,string> snapshot() const
}

' ====== Commands ======
interface IShellCommand {
  + string name() const
  + int run(vector<string> argv, int inFd, int outFd, int errFd, Environment& env)
}

class CommandRegistry {
  - map<string, unique_ptr<IShellCommand>> builtins
  + void registerCommand(unique_ptr<IShellCommand> cmd)
  + IShellCommand* find(string name) const
}

' ====== Execution ======
class Executor {
  - CommandRegistry& registry
  - ExternalProgramRunner external
  + int execute(PipelineNode pipeline, Environment& env)
}

class ExternalProgramRunner {
  + [[noreturn]] void exec(string program, vector<string> argv, map<string,string> env)
}

Shell --> Expander
Shell --> Lexer
Shell --> Parser
Shell --> Executor
Shell --> Environment

Expander --> Environment
Lexer --> Token
Token --> TokenType
Parser --> PipelineNode
PipelineNode --> CommandNode
CommandNode --> AssignmentNode

Executor --> CommandRegistry
CommandRegistry --> IShellCommand
Executor --> ExternalProgramRunner
Executor --> Environment

note bottom of IShellCommand
Используем fd (inFd/outFd/errFd), чтобы:
- builtins могли работать в пайплайне
- Executor мог настраивать потоки через dup2
end note

@enduml