# Архитектурная документация

> Целевая платформа: Linux/macOS. Механизм пайплайнов и запуска внешних программ опирается на `pipe()`, `fork()`, `dup2()`, `execvp()`, `waitpid()`.

---

## 1. Требования

### 1.1 Функциональные требования
Интерпретатор поддерживает:

**Встроенные команды (builtins):**
- `cat` — вывести содержимое файла или stdin.
- `echo` — вывести аргументы.
- `wc` — вывести количество строк, слов и байт (для файла или stdin).
- `pwd` — вывести текущую директорию.
- `exit` — завершить интерпретатор.

**Синтаксис и семантика:**
- пайплайны через оператор `|`: `cmd1 | cmd2 | cmd3`
- одинарные и двойные кавычки:
  - `'...'`: всё внутри — литерал, подстановки запрещены
  - `"..."`: литерал, но разрешены подстановки `$NAME`
- окружение:
  - присваивания вида `NAME=value` (обновляют окружение интерпретатора)
  - подстановки `$NAME` в аргументах команд

**Внешние программы:**
- если команда не является builtin, она запускается как внешняя программа через `execvp()` (поиск по `PATH`).

### 1.2 Нефункциональные требования
- легко добавлять новые команды (через реестр builtins)
- чёткое разграничение ответственности между компонентами

---

## 2. Ограничения
**не поддерживаются**:
- редиректы `>`, `<`, `>>`
- `;`, `&&`, `||`
- job control (`&`, `fg/bg`)
- globbing (`*`, `?`)
- escape-последовательности `\`
- `${VAR}`

- после подстановки `$NAME` **не выполняется word splitting**: результат подстановки не разбивается на несколько аргументов по пробелам.

---

## 3. Термины и модель потоков
- **stdin** — стандартный вход процесса (fd=0)
- **stdout** — стандартный выход процесса (fd=1)
- **stderr** — стандартный поток ошибок (fd=2)
- **Аргументы** команды (`argv`) и **входной поток** (`stdin`) — разные сущности:
  - `argv` формируется из разобранной строки
  - `stdin` — поток данных, который команда читает (из терминала или из pipe)

---

## 4. Общая структура
Исходник: `docs/diagrams/components.puml`.

Обработка одной строки:

1. `Shell` читает строку
2. `Expander` выполняет подстановки `$NAME` до токенизации
3. `Lexer` токенизирует с учётом кавычек, операторов и служебных маркеров
4. `Parser` строит объектное представление (AST)
5. `Executor` исполняет pipeline (builtins или внешние программы)

`Environment` доступен:
- из `Shell` для чтения/обновления переменных
- из `PreExpander` для чтения значений `$NAME`
- из `Executor` для формирования окружения дочерних процессов

---

## 5. Поток исполнения

### 5.1 Точка входа приложения
`main()` создаёт объект `CLI` и вызывает:
- `CLI::run()`

### 5.2 Цикл
`CLI::run()` выполняет цикл:
1. прочитать строку
2. если строка пустая/состоит из пробелов — ничего не делать, перейти к следующей итерации
3. вызвать `CLI::runLine(line)`
4. обработать код возврата
5. продолжать до получения сигнала завершения (команда `exit`)

### 5.3 Обработка одной строки
`CLI::runLine(line)` выполняет сследующие этапы:

1. **Подстановка до токенизации**: `expanded = PreExpander::expandLine(line, env)`
2. **Лексический анализ**: `tokens = Lexer::tokenize(expanded)`
3. **Синтаксический анализ**: `ast = Parser::parse(tokens)`
4. **Исполнение**: `status = Executor::execute(ast, env)`
5. вернуть `status`

---

## 6. Модель данных

### 6.1 Токены
Lexer возвращает `vector<Token>`:

- `TokenType::WORD` — готовое слово (один аргумент)
- `TokenType::PIPE` — оператор `|`
- `TokenType::EOL` — конец ввода

`Token.text` для `WORD` уже содержит:
- снятые кавычки
- результат подстановок `$NAME`
- пробелы внутри подстановки сохранены как часть одного слова (за счёт sentinel-маркеров)

### 6.2 AST
Parser строит AST:

- `PipelineNode`
  - `vector<CommandNode> commands`

- `CommandNode`
  - `vector<AssignmentNode> assignments`
  - `vector<string> words` — слова команды (первое слово — имя команды)

- `AssignmentNode`
  - `name: string`
  - `value: string` — значение после подстановок (так как подстановка уже выполнена до токенизации)

### 6.3 Модель исполнения
Expander преобразует AST в структуру, готовую к запуску:

- `ExecPipeline`
  - `vector<CommandInvocation> stages`

- `CommandInvocation`
  - `program: string` — имя команды
  - `argv: vector<string>` — аргументы (argv[0] == program)
  - `envOverlay: map<string,string>` — присваивания, применяемые к окружению запуска (если поддерживаем overlay)

---

## 7. Окружение

### 7.1 Представление окружения
`Environment` хранит переменные в:
- `map<string,string> vars`

Методы:
- `set(name, value)` — установить/обновить переменную
- `get(name) -> optional<string>` — получить значение
- `snapshot() -> map<string,string>` — получить копию для формирования `envp` при запуске внешней программы

### 7.2 Семантика присваиваний `NAME=value`
Поддерживается следующий режим:

1) Если строка состоит **только из присваиваний**:
- обновить `Environment` интерпретатора
- ничего не исполнять
- вернуть код `0` (успех), если синтаксис корректен

Пример:
```sh
FILE=example.txt
```

2) Если присваивания стоят **перед командой** (например, `X=1 echo $X`):

- присваивания попадают в `CommandInvocation.envOverlay`
- при запуске команды формируется окружение процесса как `env.snapshot() + overlay`
- переменные из `overlay` **не обязаны** сохраняться в окружении интерпретатора

---

## 8. Парсинг и токенизация

### 8.1 Подстановка НЕ до токенизации
Подстановки `$NAME` выполняются **до** лексического анализа.

Порядок обработки строки:
1) `expandedLine = PreExpander::expandLine(rawLine, env)`
2) `tokens = Lexer::tokenize(expandedLine)`
3) `ast = Parser::parse(tokens)`
4) `status = Executor::execute(ast, env)`

`PreExpander` выполняет подстановки с учётом кавычек:
- в одинарных кавычках `'...'` подстановки запрещены
- в двойных кавычках `"..."` подстановки разрешены
- вне кавычек подстановки разрешены

Поддерживается только синтаксис `$NAME`, где `NAME = [A-Za-z_][A-Za-z0-9_]*`.
Если переменная не определена — подставляется пустая строка.

### 8.1.1 Пробелы в значении переменной не разбивают аргумент
Требование проекта: если значение переменной содержит пробелы, после подстановки это должно остаться **одним аргументом**.

Так как подстановка выполняется до токенизации, `PreExpander` и `Lexer` используют протокол:
- `PreExpander` оборачивает результат подстановки в служебные маркеры (sentinel), например `\x1E` (START) и `\x1F` (END).
- `Lexer` распознаёт эти маркеры и трактует пробелы внутри как обычные символы слова, а не как разделители аргументов.

Пример:
- `X="a b"`
- ввод: `echo $X`
- после `PreExpander`: `echo <START>a b<END>`
- `Lexer` выдаёт токены: `WORD("echo")`, `WORD("a b")`

### 8.2 Lexer: алгоритм
`Lexer` — конечный автомат со состояниями:

- `Normal`
- `InSingleQuote`
- `InDoubleQuote`

`Lexer` читает строку посимвольно и формирует:

- токены `PIPE` при встрече `|` в состоянии `Normal`
- токены `WORD_PART` для сегментов слов

**Разделители слов:**

- в `Normal` пробельные символы завершают текущее слово
- в кавычках пробелы — часть литерала

**Кавычки:**

- `'` в `Normal` → переход в `InSingleQuote` (сама кавычка не попадает в результат)
- `"` в `Normal` → переход в `InDoubleQuote`
- соответствующая закрывающая кавычка завершает режим кавычек

**Сегменты:**

- в `InSingleQuote` всё читается как `Literal` до следующей `'`
- в `InDoubleQuote`:
  - обычные символы → `Literal`
  - последовательность `$` + `NAME` → сегмент `VarRef(NAME)`
- в `Normal`:
  - обычные символы → `Literal`
  - `$` + `NAME` → `VarRef(NAME)` (подстановка разрешена)

**NAME (имя переменной):**

- имя переменной: `[A-Za-z_][A-Za-z0-9_]*`
- если после `$` не начинается корректное имя, `$` трактуется как обычный символ (то есть добавляется в `Literal`)

**Ошибки лексера:**

- незакрытая кавычка → ошибка `unterminated quote`
- строка не исполняется
- возвращается фиксированный код ошибки разбора (например, `2`)

### 8.3 Parser: грамматика и построение AST
`Parser` работает по токенам и строит `PipelineNode`.

Упрощённая грамматика:

- `line := pipeline | assignment_list | assignment_list pipeline`
- `pipeline := command ('|' command)*`
- `command := (assignment)* (word)+`
- `assignment := NAME '=' word`
- `word := WORD_PART+`

**Правила корректности:**

- пайплайн не может начинаться или заканчиваться `|`
- между `|` должны быть команды
- команда должна иметь хотя бы одно слово (имя команды), если это не “только присваивания”

**Как `Parser` отличает assignment от обычного слова:**

- assignment распознаётся только в начале команды (до первого “обычного” слова команды)
- форма: `NAME=value` без пробелов вокруг `=`
- `value` — это `WordNode` (может включать сегменты и подстановки)

Пример:
- `a=b c=d echo 1` → `assignments=[a=b, c=d]`, `words=[echo, 1]`

## 9. Подстановки (PreExpander) — подробно

### 9.1 Вход и выход
Вход:
- `rawLine: string`
- `Environment env`

Выход:
- `expandedLine: string` — строка, где выполнены подстановки `$NAME`
- подставленные значения, содержащие пробелы, обёрнуты sentinel-маркерами для сохранения “одного аргумента”

### 9.2 Алгоритм `expandLine`
`PreExpander` проходит строку слева направо, поддерживая состояния:
- `Normal`
- `InSingleQuote`
- `InDoubleQuote`

Правила:
- в `InSingleQuote` символ `$` не запускает подстановку
- в `Normal` и `InDoubleQuote` последовательность `$NAME` заменяется на значение переменной
- если переменная не определена — подставляется пустая строка
- если подставляемое значение содержит пробелы или табы, оно оборачивается sentinel-маркерами START/END

### 9.3 Склейка `$x$y`
Подстановки выполняются последовательно, поэтому конструкция `$x$y` корректна:
- `$x` заменяется на значение `x`
- затем `$y` заменяется на значение `y`
Результат является частью одного слова, если между ними нет разделителей.

## 10. Команды

### 10.1 Реестр команд (`CommandRegistry`)
`CommandRegistry` хранит builtins:

- ключ: имя команды (`"echo"`, `"wc"`, …)
- значение: объект, реализующий `IShellCommand`

Добавление новой builtin-команды:

1. реализовать класс `XCommand : IShellCommand`
2. зарегистрировать его в `CommandRegistry::registerCommand(...)`
3. `Executor` автоматически начнёт находить её по имени

Это обеспечивает расширяемость без изменения `Lexer/Parser/Expander`.

### 10.2 Интерфейс builtin-команды (`IShellCommand`)
`IShellCommand`:

- `name() -> string`
- `run(argv, in, out, err, env) -> int`

Требования к builtin:

- builtin не должен “читать аргументы” из stdin: аргументы приходят через `argv`
- stdin используется только для потоковых данных (например, `cat` без файла читает stdin)
- builtin должен писать результат в `out`, а ошибки — в `err`, чтобы корректно работать в пайплайне

### 10.3 Поведение встроенных команд
Ниже — минимальная спецификация, чтобы не принимать решения при кодировании.

#### `echo`
- печатает все аргументы `argv[1..]`, разделяя одним пробелом
- завершает строкой `\n`
- не интерпретирует escape-последовательности
- код возврата: `0`

#### `pwd`
- печатает текущую директорию + `\n`
- код возврата: `0` при успехе, иначе `1`

#### `cat`
- если указан файл `argv[1]`: печатает содержимое файла в `out`
- если файл не указан: читает из `in` и копирует в `out` до EOF
- при ошибке открытия файла: сообщение в `err`, код `1`

#### `wc`
- если указан файл `argv[1]`: считает по содержимому файла
- если файл не указан: считает по `in` до EOF
- выводит: `<lines> <words> <bytes>\n`
- определения:
  - `bytes` — количество байт во входном потоке
  - `lines` — количество символов `'\n'`
  - `words` — количество “слов” как последовательностей непробельных символов (whitespace-разделители)
- при ошибке открытия файла: сообщение в `err`, код `1`

#### `exit`
- если вызван как единственная команда строки (не в пайплайне) — завершает REPL
- код возврата интерпретатора: `0` (или можно поддержать `exit N`, но это отдельное решение; по умолчанию не поддерживаем)
- если `exit` находится внутри пайплайна — выполняется как обычная стадия и **не завершает** REPL (см. раздел про завершение)

---

## 11. Executor

### 11.1 Общая ответственность `Executor`
`Executor` получает `ExecPipeline` и:

- для каждой стадии определяет: builtin или external
- создаёт pipe между стадиями
- запускает стадии так, чтобы stdout стадии `i` был подключён к stdin стадии `i+1`
- собирает коды возврата и возвращает итоговый статус

`Executor` **не**:

- не парсит строку
- не выполняет подстановки
- не интерпретирует кавычки

### 11.2 Исполнение пайплайна через процессы ОС
Для пайплайна из `N` стадий создаются `N-1` pipe:

- `pipe[i] = (r[i], w[i])` связывает стадию `i` со стадией `i+1`

Для каждой стадии `i`:

1. `fork()`
2. в дочернем процессе:
   - если `i > 0`: `dup2(r[i-1], STDIN_FILENO)`
   - если `i < N-1`: `dup2(w[i], STDOUT_FILENO)`
   - закрыть **все** `r[*]` и `w[*]` (после `dup2`), чтобы не держать лишние дескрипторы
   - выполнить команду:
     - builtin: вызвать `IShellCommand::run(...)`, затем `_exit(code)`
     - external: вызвать `execvp(program, argv)` (при ошибке — вывести в stderr и `_exit(127)`)

В родительском процессе:

- закрыть все `r[*]` и `w[*]` после запуска детей
- дождаться завершения всех дочерних процессов через `waitpid`

**Почему builtins запускаются в дочернем процессе:**

- чтобы они корректно участвовали в пайплайне (читали/писали через pipe)
- чтобы единообразно управлять stdin/stdout через `dup2`

### 11.3 Формирование окружения процесса (env + overlay)
Перед запуском стадии формируется окружение:

- базовое окружение: `env.snapshot()`
- поверх него накладывается `CommandInvocation.envOverlay` (если есть)
- итоговое окружение передаётся дочернему процессу

Важно то, что overlay применяется на уровне процесса

### 11.4 Внешние программы
Запуск внешней программы выполняется так:

- `fork()` создаёт дочерний процесс
- в дочернем процессе настраиваются потоки (`dup2`)
- затем вызывается `execvp(program, argv)`:
  - поиск исполняемого файла выполняется по `PATH`
  - при успехе текущий процесс заменяется образом внешней программы
  - при ошибке `execvp` возвращает управление (тогда печатаем ошибку и завершаем процесс)

Ошибки:

- “команда не найдена” → код `127`
- “не удалось запустить” (например, нет прав) → код `126`

### 11.5 Потоки ошибок (`stderr`)
`stderr` (fd=2) по умолчанию не подключается к пайплайну и остаётся направленным в терминал.

- builtin пишет ошибки в `err`
- external программа пишет в свой stderr

---

## 12. Коды возврата

### 12.1 Коды возврата builtins
Каждая builtin-команда возвращает `int`:

- `0` — успех
- `>0` — ошибка

Рекомендуемые значения:

- `cat`: `1` при ошибке открытия/чтения файла
- `wc`: `1` при ошибке открытия/чтения файла
- `pwd`: `1` при ошибке получения директории
- `echo`: `0`
- `exit`: `0` (как команда), но дополнительно инициирует завершение

### 12.2 Итоговый код пайплайна
- код возврата пайплайна = код возврата **последней** команды в пайплайне

`Executor::execute(...)` возвращает этот код в `CLI::runLine`.

### 12.3 Ошибки лексинга/парсинга
Если строка не может быть разобрана (например, незакрытые кавычки, `|` в конце):

- команда не исполняется
- возвращается фиксированный код ошибки разбора
- сообщение об ошибке печатается в stderr интерпретатора

---

## 13. Завершение работы по `exit`

`exit` — builtin-команда.

Архитектурное решение:

- если строка — это **одна команда** `exit` (без пайплайна), то завершаемся
- если `exit` находится внутри пайплайна, он выполняется как обычная стадия (в дочернем процессе) и **не должен** завершать родительский REPL

- `Executor` возвращает не только `code`, но и флаг `shouldTerminateCLI`
- `CLI::runLine` проверяет флаг и завершает цикл `run()`

---

## 14. Пример работы

Сценарий: `cat example.txt | wc`

Ключевые шаги:

1. CLI читает строку
2. Lexer токенизирует
3. Parser строит AST
4. Expander формирует `ExecPipeline`
5. Executor:
   - создаёт pipe
   - fork для `cat`, переназначает stdout в pipe, запускает команду
   - fork для `wc`, переназначает stdin из pipe, запускает команду
   - закрывает fd в родителе, ждёт детей
6. CLI печатает результат (stdout последней команды направлен в терминал)
