# Архитектурная документация

> Целевая платформа: Linux/macOS. Механизм пайплайнов и запуска внешних программ опирается на `pipe()`, `fork()`, `dup2()`, `execvp()`, `waitpid()`.

---

## 1. Требования

### 1.1 Функциональные требования
Интерпретатор поддерживает:

**Встроенные команды (builtins):**
- `cat` — вывести содержимое файла или stdin.
- `echo` — вывести аргументы.
- `wc` — вывести количество строк, слов и байт (для файла или stdin).
- `pwd` — вывести текущую директорию.
- `exit` — завершить интерпретатор.

**Синтаксис и семантика:**
- пайплайны через оператор `|`: `cmd1 | cmd2 | cmd3`
- одинарные и двойные кавычки:
  - `'...'`: всё внутри — литерал, подстановки запрещены
  - `"..."`: литерал, но разрешены подстановки `$NAME`
- окружение:
  - присваивания вида `NAME=value` (обновляют окружение интерпретатора)
  - подстановки `$NAME` в аргументах команд

**Внешние программы:**
- если команда не является builtin, она запускается как внешняя программа через `execvp()` (поиск по `PATH`).

### 1.2 Нефункциональные требования
- легко добавлять новые команды (через реестр builtins)
- чёткое разграничение ответственности между компонентами

---

## 2. Ограничения
**не поддерживаются**:
- редиректы `>`, `<`, `>>`
- `;`, `&&`, `||`
- job control (`&`, `fg/bg`)
- globbing (`*`, `?`)
- escape-последовательности `\`
- `${VAR}`

- после подстановки `$NAME` **не выполняется word splitting**: результат подстановки не разбивается на несколько аргументов по пробелам.

---

## 3. Термины и модель потоков
- **stdin** — стандартный вход процесса (fd=0)
- **stdout** — стандартный выход процесса (fd=1)
- **stderr** — стандартный поток ошибок (fd=2)
- **Аргументы** команды (`argv`) и **входной поток** (`stdin`) — разные сущности:
  - `argv` формируется из разобранной строки
  - `stdin` — поток данных, который команда читает (из терминала или из pipe)

---

## 4. Общая структура
Исходник: `docs/diagrams/components.puml`.

Обработка одной строки:

1. `CLI` читает строку
2. `Lexer` токенизирует с учётом кавычек
3. `Parser` строит объектное представление
4. `Expander` выполняет подстановки окружения `$NAME`
5. `Executor` исполняет pipeline (builtins или внешние программы)

`Environment` доступен для чтения/обновления из `CLI`, для чтения из `Expander`, и для формирования окружения дочерних процессов в `Executor`.

---

## 5. Поток исполнения

### 5.1 Точка входа приложения
`main()` создаёт объект `CLI` и вызывает:
- `CLI::run()`

### 5.2 Цикл
`CLI::run()` выполняет цикл:
1. прочитать строку
2. если строка пустая/состоит из пробелов — ничего не делать, перейти к следующей итерации
3. вызвать `CLI::runLine(line)`
4. обработать код возврата
5. продолжать до получения сигнала завершения (команда `exit`)

### 5.3 Обработка одной строки
`CLI::runLine(line)` выполняет сследующие этапы:

1. **Лексический анализ**: `tokens = Lexer::tokenize(line)`
2. **Синтаксический анализ**: `ast = Parser::parse(tokens)`
3. **Подстановки**: `execPipeline = Expander::expand(ast, env)`
4. **Исполнение**: `status = Executor::execute(execPipeline, env)`
5. вернуть `status`

---

## 6. Модель данных

### 6.1 Токены
Lexer возвращает `vector<Token>`, где:
- `TokenType::WORD_PART` — часть слова
- `TokenType::PIPE` — оператор `|`
- `TokenType::EOL` — конец ввода

Каждый `WORD_PART` несёт:
- `text` — текст сегмента
- `segmentKind`:
  - `Literal` — обычный текст
  - `VarRef` — ссылка на переменную (имя без `$`)

### 6.2 AST
Parser строит AST:

- `PipelineNode`
  - `vector<CommandNode> commands`

- `CommandNode`
  - `vector<AssignmentNode> assignments` — присваивания `NAME=value` перед командой
  - `vector<WordNode> words` — слова команды

- `WordNode`
  - `vector<Segment> segments`

- `Segment`
  - `kind: Literal | VarRef`
  - `text: string` (для Literal — текст, для VarRef — имя переменной)

- `AssignmentNode`
  - `name: string`
  - `value: WordNode`

### 6.3 Модель исполнения
Expander преобразует AST в структуру, готовую к запуску:

- `ExecPipeline`
  - `vector<CommandInvocation> stages`

- `CommandInvocation`
  - `program: string` — имя команды
  - `argv: vector<string>` — аргументы (argv[0] == program)
  - `envOverlay: map<string,string>` — присваивания, применяемые к окружению запуска (если поддерживаем overlay)

---

## 7. Окружение

### 7.1 Представление окружения
`Environment` хранит переменные в:
- `map<string,string> vars`

Методы:
- `set(name, value)` — установить/обновить переменную
- `get(name) -> optional<string>` — получить значение
- `snapshot() -> map<string,string>` — получить копию для формирования `envp` при запуске внешней программы

### 7.2 Семантика присваиваний `NAME=value`
Поддерживается следующий режим:

1) Если строка состоит **только из присваиваний**:
- обновить `Environment` интерпретатора
- ничего не исполнять
- вернуть код `0` (успех), если синтаксис корректен

Пример:
```sh
FILE=example.txt
```

2) Если присваивания стоят **перед командой** (например, `X=1 echo $X`):

- присваивания попадают в `CommandInvocation.envOverlay`
- при запуске команды формируется окружение процесса как `env.snapshot() + overlay`
- переменные из `overlay` **не обязаны** сохраняться в окружении интерпретатора

---

## 8. Парсинг и токенизация

### 8.1 Подстановка НЕ до токенизации
Подстановки `$NAME` **не выполняются до токенизации**. Причины:

- правила кавычек влияют на то, где подстановка разрешена
- корректная обработка `$` требует знания контекста
- подстановка до токенизации ломает структуру токенов и усложняет корректный разбор

Следовательно:

- сначала `Lexer` формирует токены/сегменты с пометками `VarRef`
- затем `Expander` выполняет подстановки на уровне сегментов

### 8.2 Lexer: алгоритм
`Lexer` — конечный автомат со состояниями:

- `Normal`
- `InSingleQuote`
- `InDoubleQuote`

`Lexer` читает строку посимвольно и формирует:

- токены `PIPE` при встрече `|` в состоянии `Normal`
- токены `WORD_PART` для сегментов слов

**Разделители слов:**

- в `Normal` пробельные символы завершают текущее слово
- в кавычках пробелы — часть литерала

**Кавычки:**

- `'` в `Normal` → переход в `InSingleQuote` (сама кавычка не попадает в результат)
- `"` в `Normal` → переход в `InDoubleQuote`
- соответствующая закрывающая кавычка завершает режим кавычек

**Сегменты:**

- в `InSingleQuote` всё читается как `Literal` до следующей `'`
- в `InDoubleQuote`:
  - обычные символы → `Literal`
  - последовательность `$` + `NAME` → сегмент `VarRef(NAME)`
- в `Normal`:
  - обычные символы → `Literal`
  - `$` + `NAME` → `VarRef(NAME)` (подстановка разрешена)

**NAME (имя переменной):**

- имя переменной: `[A-Za-z_][A-Za-z0-9_]*`
- если после `$` не начинается корректное имя, `$` трактуется как обычный символ (то есть добавляется в `Literal`)

**Ошибки лексера:**

- незакрытая кавычка → ошибка `unterminated quote`
- строка не исполняется
- возвращается фиксированный код ошибки разбора (например, `2`)

### 8.3 Parser: грамматика и построение AST
`Parser` работает по токенам и строит `PipelineNode`.

Упрощённая грамматика:

- `line := pipeline | assignment_list | assignment_list pipeline`
- `pipeline := command ('|' command)*`
- `command := (assignment)* (word)+`
- `assignment := NAME '=' word`
- `word := WORD_PART+`

**Правила корректности:**

- пайплайн не может начинаться или заканчиваться `|`
- между `|` должны быть команды
- команда должна иметь хотя бы одно слово (имя команды), если это не “только присваивания”

**Как `Parser` отличает assignment от обычного слова:**

- assignment распознаётся только в начале команды (до первого “обычного” слова команды)
- форма: `NAME=value` без пробелов вокруг `=`
- `value` — это `WordNode` (может включать сегменты и подстановки)

Пример:
- `a=b c=d echo 1` → `assignments=[a=b, c=d]`, `words=[echo, 1]`

## 9. Подстановки (Expander)

### 9.1 Вход и выход
Вход:

- `PipelineNode ast`
- `Environment env`

Выход:

- `ExecPipeline`, где каждая стадия содержит готовый `argv` и `envOverlay`.

### 9.2 `expandWord`
`expandWord(WordNode w, Environment env) -> string`:

1. создать пустую строку `result`
2. для каждого `Segment s` в `w.segments`:
   - если `s.kind == Literal`: дописать `s.text` в `result`
   - если `s.kind == VarRef`:
     - `val = env.get(s.text)`
     - если `val` существует: дописать `val`
     - иначе: дописать пустую строку
3. вернуть `result`

результат — одна строка, не разбивается на несколько аргументов.

### 9.3 Подстановки в присваиваниях
Значение `AssignmentNode.value` — это `WordNode`, значит:

- подстановки `$NAME` в значениях присваиваний выполняются тем же механизмом `expandWord`
- затем результат кладётся в `envOverlay[name]` (если присваивания относятся к конкретной команде)
- либо сохраняется в `Environment` интерпретатора (если строка состоит только из присваиваний)

### 9.4 Пустые результаты подстановок
Если подстановка дала пустую строку:

- сегмент просто “исчезает” при склейке
- аргумент может стать пустой строкой `""` (например, `echo "$UNDEF"` → один аргумент пустая строка)
- если слово целиком стало пустым **вне кавычек**, поведение фиксируем как: аргумент остаётся пустым (мы не удаляем аргументы автоматически)

---

## 10. Команды

### 10.1 Реестр команд (`CommandRegistry`)
`CommandRegistry` хранит builtins:

- ключ: имя команды (`"echo"`, `"wc"`, …)
- значение: объект, реализующий `IShellCommand`

Добавление новой builtin-команды:

1. реализовать класс `XCommand : IShellCommand`
2. зарегистрировать его в `CommandRegistry::registerCommand(...)`
3. `Executor` автоматически начнёт находить её по имени

Это обеспечивает расширяемость без изменения `Lexer/Parser/Expander`.

### 10.2 Интерфейс builtin-команды (`IShellCommand`)
`IShellCommand`:

- `name() -> string`
- `run(argv, in, out, err, env) -> int`

Требования к builtin:

- builtin не должен “читать аргументы” из stdin: аргументы приходят через `argv`
- stdin используется только для потоковых данных (например, `cat` без файла читает stdin)
- builtin должен писать результат в `out`, а ошибки — в `err`, чтобы корректно работать в пайплайне

### 10.3 Поведение встроенных команд
Ниже — минимальная спецификация, чтобы не принимать решения при кодировании.

#### `echo`
- печатает все аргументы `argv[1..]`, разделяя одним пробелом
- завершает строкой `\n`
- не интерпретирует escape-последовательности
- код возврата: `0`

#### `pwd`
- печатает текущую директорию + `\n`
- код возврата: `0` при успехе, иначе `1`

#### `cat`
- если указан файл `argv[1]`: печатает содержимое файла в `out`
- если файл не указан: читает из `in` и копирует в `out` до EOF
- при ошибке открытия файла: сообщение в `err`, код `1`

#### `wc`
- если указан файл `argv[1]`: считает по содержимому файла
- если файл не указан: считает по `in` до EOF
- выводит: `<lines> <words> <bytes>\n`
- определения:
  - `bytes` — количество байт во входном потоке
  - `lines` — количество символов `'\n'`
  - `words` — количество “слов” как последовательностей непробельных символов (whitespace-разделители)
- при ошибке открытия файла: сообщение в `err`, код `1`

#### `exit`
- если вызван как единственная команда строки (не в пайплайне) — завершает REPL
- код возврата интерпретатора: `0` (или можно поддержать `exit N`, но это отдельное решение; по умолчанию не поддерживаем)
- если `exit` находится внутри пайплайна — выполняется как обычная стадия и **не завершает** REPL (см. раздел про завершение)

---

## 11. Executor

### 11.1 Общая ответственность `Executor`
`Executor` получает `ExecPipeline` и:

- для каждой стадии определяет: builtin или external
- создаёт pipe между стадиями
- запускает стадии так, чтобы stdout стадии `i` был подключён к stdin стадии `i+1`
- собирает коды возврата и возвращает итоговый статус

`Executor` **не**:

- не парсит строку
- не выполняет подстановки
- не интерпретирует кавычки

### 11.2 Исполнение пайплайна через процессы ОС
Для пайплайна из `N` стадий создаются `N-1` pipe:

- `pipe[i] = (r[i], w[i])` связывает стадию `i` со стадией `i+1`

Для каждой стадии `i`:

1. `fork()`
2. в дочернем процессе:
   - если `i > 0`: `dup2(r[i-1], STDIN_FILENO)`
   - если `i < N-1`: `dup2(w[i], STDOUT_FILENO)`
   - закрыть **все** `r[*]` и `w[*]` (после `dup2`), чтобы не держать лишние дескрипторы
   - выполнить команду:
     - builtin: вызвать `IShellCommand::run(...)`, затем `_exit(code)`
     - external: вызвать `execvp(program, argv)` (при ошибке — вывести в stderr и `_exit(127)`)

В родительском процессе:

- закрыть все `r[*]` и `w[*]` после запуска детей
- дождаться завершения всех дочерних процессов через `waitpid`

**Почему builtins запускаются в дочернем процессе:**

- чтобы они корректно участвовали в пайплайне (читали/писали через pipe)
- чтобы единообразно управлять stdin/stdout через `dup2`

### 11.3 Формирование окружения процесса (env + overlay)
Перед запуском стадии формируется окружение:

- базовое окружение: `env.snapshot()`
- поверх него накладывается `CommandInvocation.envOverlay` (если есть)
- итоговое окружение передаётся дочернему процессу

Важно то, что overlay применяется на уровне процесса

### 11.4 Внешние программы
Запуск внешней программы выполняется так:

- `fork()` создаёт дочерний процесс
- в дочернем процессе настраиваются потоки (`dup2`)
- затем вызывается `execvp(program, argv)`:
  - поиск исполняемого файла выполняется по `PATH`
  - при успехе текущий процесс заменяется образом внешней программы
  - при ошибке `execvp` возвращает управление (тогда печатаем ошибку и завершаем процесс)

Ошибки:

- “команда не найдена” → код `127`
- “не удалось запустить” (например, нет прав) → код `126`

### 11.5 Потоки ошибок (`stderr`)
`stderr` (fd=2) по умолчанию не подключается к пайплайну и остаётся направленным в терминал.

- builtin пишет ошибки в `err`
- external программа пишет в свой stderr

---

## 12. Коды возврата

### 12.1 Коды возврата builtins
Каждая builtin-команда возвращает `int`:

- `0` — успех
- `>0` — ошибка

Рекомендуемые значения:

- `cat`: `1` при ошибке открытия/чтения файла
- `wc`: `1` при ошибке открытия/чтения файла
- `pwd`: `1` при ошибке получения директории
- `echo`: `0`
- `exit`: `0` (как команда), но дополнительно инициирует завершение

### 12.2 Итоговый код пайплайна
- код возврата пайплайна = код возврата **последней** команды в пайплайне

`Executor::execute(...)` возвращает этот код в `CLI::runLine`.

### 12.3 Ошибки лексинга/парсинга
Если строка не может быть разобрана (например, незакрытые кавычки, `|` в конце):

- команда не исполняется
- возвращается фиксированный код ошибки разбора
- сообщение об ошибке печатается в stderr интерпретатора

---

## 13. Завершение работы по `exit`

`exit` — builtin-команда.

Архитектурное решение:

- если строка — это **одна команда** `exit` (без пайплайна), то завершаемся
- если `exit` находится внутри пайплайна, он выполняется как обычная стадия (в дочернем процессе) и **не должен** завершать родительский REPL

- `Executor` возвращает не только `code`, но и флаг `shouldTerminateCLI`
- `CLI::runLine` проверяет флаг и завершает цикл `run()`

---

## 14. Пример работы

Сценарий: `cat example.txt | wc`

Ключевые шаги:

1. CLI читает строку
2. Lexer токенизирует
3. Parser строит AST
4. Expander формирует `ExecPipeline`
5. Executor:
   - создаёт pipe
   - fork для `cat`, переназначает stdout в pipe, запускает команду
   - fork для `wc`, переназначает stdin из pipe, запускает команду
   - закрывает fd в родителе, ждёт детей
6. CLI печатает результат (stdout последней команды направлен в терминал)
