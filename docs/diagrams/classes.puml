@startuml classes
title диаграмма классы
skinparam shadowing false
skinparam classAttributeIconSize 0

class Shell {
  - Environment env
  - Lexer lexer
  - Parser parser
  - Expander expander
  - Executor executor
  + int run()
  + void runLine(string line)
}

class Lexer {
  + vector<Token> tokenize(string line)
}

enum TokenType {
  WORD_PART
  PIPE
  EOL
}

class Token {
  + TokenType type
  + string text
  + SegmentKind segmentKind
}

enum SegmentKind {
  Literal  ' обычный текст
  VarRef   ' ссылка на переменную ($NAME)
}

class Parser {
  + PipelineNode parse(vector<Token> tokens)
}

class PipelineNode {
  + vector<CommandNode> commands
}

class CommandNode {
  + vector<WordNode> words
  + vector<AssignmentNode> assignments
}

class WordNode {
  + vector<Segment> segments
}

class Segment {
  + SegmentKind kind
  + string text  ' literal-текст ИЛИ имя переменной
}

class AssignmentNode {
  + string name
  + WordNode value
}

class Expander {
  + ExecPipeline expand(PipelineNode ast, Environment env)
  - string expandWord(WordNode w, Environment env)
}

class ExecPipeline {
  + vector<CommandInvocation> stages
}

class CommandInvocation {
  + string program
  + vector<string> argv
  + map<string,string> envOverlay
}

class Environment {
  - map<string,string> vars
  + void set(string name, string value)
  + optional<string> get(string name) const
  + map<string,string> snapshot() const
}

interface IShellCommand {
  + string name() const
  + int run(vector<string> argv, IStream& in, IStream& out, IStream& err, Environment& env)
}

class CommandRegistry {
  - map<string, unique_ptr<IShellCommand>> builtins
  + void registerCommand(unique_ptr<IShellCommand> cmd)
  + IShellCommand* find(string name) const
}

class Executor {
  - CommandRegistry& registry
  - ExternalProgramRunner external
  + int execute(ExecPipeline pipeline, Environment& env)
  - int runPipeline(vector<CommandInvocation> stages, Environment& env)
  - int runStage(CommandInvocation cmd, int inFd, int outFd, Environment& env)
}

class ExternalProgramRunner {
  + void exec(CommandInvocation cmd, map<string,string> env)
}

Shell --> Lexer
Shell --> Parser
Shell --> Expander
Shell --> Executor
Shell --> Environment

Lexer --> Token
Token --> TokenType
Token --> SegmentKind

Parser --> PipelineNode
PipelineNode --> CommandNode
CommandNode --> WordNode
CommandNode --> AssignmentNode
WordNode --> Segment
Segment --> SegmentKind
AssignmentNode --> WordNode

Expander --> ExecPipeline
ExecPipeline --> CommandInvocation
Expander --> Environment

Executor --> CommandRegistry
CommandRegistry --> IShellCommand
Executor --> ExternalProgramRunner
Executor --> Environment

note right of IShellCommand
Встроенные команды: cat, echo, wc, pwd, exit.

Чтобы поддержать пайплайны, встроенная команда
должна уметь читать из входного потока и писать
в выходной поток (или работать через fd).
end note

note bottom of ExternalProgramRunner
Запуск внешней программы выполняется через ОС:
fork/execvp, а окружение передаётся как envp.
end note

note bottom of CommandInvocation
argv хранится уже после:
- обработки кавычек
- подстановок $NAME
То есть Executor не занимается парсингом строки.
end note

@enduml
